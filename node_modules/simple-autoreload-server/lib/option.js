/*
 * simple-autoreload-server v0.2.7 - 2017-09-07
 * <https://github.com/cytb/simple-autoreload-server>
 *
 * Copyright (c) 2017 cytb
 *
 * Licensed under the MIT License.
 */

(function(){
  var Minimatch, path, isArray, convertToKeys, flatten, cloneRegex, optionsSource, ParseHelper, OptionHelper, split$ = ''.split, slice$ = [].slice, join$ = [].join, toString$ = {}.toString, out$ = typeof exports != 'undefined' && exports || this;
  Minimatch = require('minimatch').Minimatch;
  path = require('path');
  isArray = (function(it){
    return it instanceof Array;
  });
  convertToKeys = function(){
    var toCamelCase;
    toCamelCase = function(it){
      var ref$, head, rest;
      ref$ = split$.call(it, /-|_/), head = ref$[0], rest = slice$.call(ref$, 1);
      return join$.call([head].concat(rest.map(function(it){
        return it.replace(/^./, function(it){
          return it.toUpperCase();
        });
      })), '');
    };
    return function(key, joiner, ch){
      var ref$, i$, keys, leaf;
      ch == null && (ch = '.');
      ref$ = key.split(ch).map(toCamelCase), keys = 0 < (i$ = ref$.length - 1) ? slice$.call(ref$, 0, i$) : (i$ = 0, []), leaf = ref$[i$];
      return [keys.join(joiner), leaf];
    };
  }();
  flatten = function(array){
    var fn$ = curry$(function(x$, y$){
      return x$.concat(y$);
    });
    if (isArray(array)) {
      while (array.some(isArray)) {
        array = array.reduce(fn$, []);
      }
    }
    return array;
  };
  cloneRegex = function(it){
    var name, flag;
    return new RegExp(it.source, (function(it){
      return join$.call(it, '');
    })((function(){
      var ref$, results$ = [];
      for (name in ref$ = {
        global: it.global,
        ignoreCase: it.ignoreCase,
        multiline: it.multiline
      }) {
        flag = ref$[name];
        results$.push(flag && name.charAt(0) || '');
      }
      return results$;
    }())));
  };
  optionsSource = require("./option-list").options;
  ParseHelper = (function(){
    ParseHelper.displayName = 'ParseHelper';
    var prototype = ParseHelper.prototype, constructor = ParseHelper;
    function ParseHelper(optionMap){
      this.optionMap = optionMap;
      this.parsed = {};
      this.unknown = {};
    }
    prototype.set = function(out, fullKey, value){
      var ref$, base, key, key$, i$, x$, len$;
      ref$ = convertToKeys(fullKey, '.', '.'), base = ref$[0], key = ref$[1];
      out = (ref$ = out[key$ = base || key]) != null
        ? ref$
        : out[key$] = [];
      if (base) {
        value = (ref$ = {}, ref$[key] = value, ref$);
        for (i$ = 0, len$ = out.length; i$ < len$; ++i$) {
          x$ = out[i$];
          if (x$[key] == null) {
            import$(x$, value);
            return;
          }
        }
      }
      return out.push(value);
    };
    prototype.prepare = function(target, key, value){
      var ref$, ref1$;
      this.target = target;
      this.key = key;
      this.value = value != null ? value : true;
      if (((ref$ = this.optionMap[this.target]) != null ? (ref1$ = ref$[this.key]) != null ? ref1$.type : void 8 : void 8) === 'boolean') {
        return this.push();
      }
    };
    prototype.push = function(value){
      value == null && (value = this.value);
      switch (false) {
      case this.value == null:
        this.put(this.target, this.key, value);
        break;
      case value == null:
        this.set(this.unknown, "rest", value);
      }
      return this.value = null;
    };
    prototype.put = function(target, key, value){
      var that, ref$, ref1$, ref2$;
      if ((that = (ref$ = this.optionMap[target]) != null ? ref$[key] : void 8) != null) {
        return this.set(this.parsed, that.label, value);
      } else {
        return this.set((ref2$ = (ref1$ = this.unknown)[target]) != null
          ? ref2$
          : ref1$[target] = {}, key, value);
      }
    };
    return ParseHelper;
  }());
  OptionHelper = (function(){
    OptionHelper.displayName = 'OptionHelper';
    var prototype = OptionHelper.prototype, constructor = OptionHelper;
    OptionHelper.parse = function(it){
      return new OptionHelper(it).parse();
    };
    OptionHelper.readPattern = function(pattern, nocase, dots){
      dots == null && (dots = false);
      switch (toString$.call(pattern).slice(8, -1)) {
      case 'Array':
        return compose$(curry$(function(x$, y$){
          return y$(x$);
        }), bind$(pattern.map(partialize$.apply(arguments, [arguments.callee, [void 8, nocase, dots], [0]])), 'every'));
      case 'String':
        return bind$(new Minimatch(pattern, {
          nocase: nocase,
          dots: dots
        }), 'match');
      case 'RegExp':
        return bind$(cloneRegex(pattern), 'test');
      case 'Function':
        return pattern;
      default:
        return function(){
          return pattern;
        };
      }
    };
    function OptionHelper(optionList, defaults){
      var i$, ref$, len$, optionEntry, key, value, ref1$, ref2$;
      this.optionList = optionList != null ? optionList : optionsSource;
      this.defaults = defaults != null
        ? defaults
        : {};
      this.optionMap = {};
      for (i$ = 0, len$ = (ref$ = this.optionList).length; i$ < len$; ++i$) {
        optionEntry = ref$[i$];
        for (key in optionEntry) {
          value = optionEntry[key];
          ((ref2$ = (ref1$ = this.optionMap)[key]) != null
            ? ref2$
            : ref1$[key] = {})[value] = optionEntry;
        }
      }
    }
    prototype.parse = function(argv){
      var ope, i$, len$, arg, ref$, matched, isFullOption, negate, key, hasValue, value, target, j$, skeys;
      argv == null && (argv = process.argv.slice(2));
      ope = new ParseHelper(this.optionMap);
      for (i$ = 0, len$ = argv.length; i$ < len$; ++i$) {
        arg = argv[i$];
        ref$ = (ref$ = /^-(-)?((no-|without-)?([^=]+))(=(.+))?/.exec(arg)) != null
          ? ref$
          : [], matched = ref$[0], isFullOption = ref$[1], negate = ref$[3], key = ref$[4], hasValue = ref$[5], value = ref$[6];
        if (!matched) {
          ope.push(arg);
          continue;
        }
        ope.push();
        target = "label";
        if (isFullOption) {
          if (!hasValue) {
            value = !negate;
          }
        } else {
          target = "short";
          ref$ = split$.call(key, ''), skeys = 0 < (j$ = ref$.length - 1) ? slice$.call(ref$, 0, j$) : (j$ = 0, []), key = ref$[j$];
          skeys.forEach(partialize$.apply(ope, [ope.put, [target, void 8, true], [1]]));
        }
        ope.prepare(target, key, value);
      }
      ope.push();
      (function(){
        this.full = this.label;
        delete this.label;
      }.call(ope.unknown));
      return {
        parsed: ope.parsed,
        unknown: ope.unknown
      };
    };
    prototype.defaultOption = function(option, key, entry, defaults, options){
      var value, that;
      value = (function(){
        switch (false) {
        case (that = option != null ? option[key] : void 8) == null:
          return that;
        case (that = defaults != null ? defaults[key] : void 8) == null:
          return that(options, this.optionMap);
        case (that = entry != null ? entry.def : void 8) == null:
          return that;
        default:
          return null;
        }
      }.call(this));
      return option[key] = (function(){
        switch (entry.type) {
        case 'number':
          return (isArray(value) && value.pop() || value) * 1;
        default:
          return value;
        }
      }());
    };
    prototype.assure = function(options, defaults){
      var nodes, i$, ref$, len$, entry, label, ref1$, base, key, primary, node, name, option;
      defaults == null && (defaults = this.defaults);
      options = import$({}, options);
      nodes = {};
      for (i$ = 0, len$ = (ref$ = this.optionList).length; i$ < len$; ++i$) {
        entry = ref$[i$], label = entry.label;
        ref1$ = convertToKeys(label, '', '.'), base = ref1$[0], key = ref1$[1];
        if (!base) {
          (fn$.call(this, options[key]));
          this.defaultOption(options, key, entry, defaults[key] != null, options);
          continue;
        }
        primary = nodes[base] == null;
        ((ref1$ = nodes[base]) != null
          ? ref1$
          : nodes[base] = {})[key] = entry;
        if (!primary) {
          continue;
        }
        options[base] = compose$(fn1$, flatten)(fn2$);
      }
      for (base in nodes) {
        node = nodes[base];
        for (name in node) {
          entry = node[name];
          for (i$ = 0, len$ = (ref$ = options[base]).length; i$ < len$; ++i$) {
            option = ref$[i$];
            this.defaultOption(option, name, entry, defaults[base] != null, options);
          }
        }
      }
      return options;
      function fn$(it){
        isArray(it) && (options[key] = it[it.length - 1]);
      }
      function fn1$(it){
        return typeof it == 'function' ? it(options[base]) : void 8;
      }
      function fn2$(obj){
        var ref$;
        switch (false) {
        case typeof obj !== 'string':
          return [(ref$ = {}, ref$[key] = obj, ref$)];
        case obj != null:
          return [];
        case !isArray(obj):
          return obj.map(arguments.callee);
        case !isArray(obj[key]):
          return obj[key].map(function(it){
            var ref$;
            return ref$ = clone$(obj), ref$[key] = it, ref$;
          });
        case obj[key] == null:
          return [obj];
        default:
          return [];
        }
      }
    };
    return OptionHelper;
  }());
  out$.OptionHelper = OptionHelper;
  function curry$(f, bound){
    var context,
    _curry = function(args) {
      return f.length > 1 ? function(){
        var params = args ? args.concat() : [];
        context = bound ? context || this : this;
        return params.push.apply(params, arguments) <
            f.length && arguments.length ?
          _curry.call(context, params) : f.apply(context, params);
      } : f;
    };
    return _curry();
  }
  function import$(obj, src){
    var own = {}.hasOwnProperty;
    for (var key in src) if (own.call(src, key)) obj[key] = src[key];
    return obj;
  }
  function compose$() {
    var functions = arguments;
    return function() {
      var i, result;
      result = functions[0].apply(this, arguments);
      for (i = 1; i < functions.length; ++i) {
        result = functions[i](result);
      }
      return result;
    };
  }
  function bind$(obj, key, target){
    return function(){ return (target || obj)[key].apply(obj, arguments) };
  }
  function partialize$(f, args, where){
    var context = this;
    return function(){
      var params = slice$.call(arguments), i,
          len = params.length, wlen = where.length,
          ta = args ? args.concat() : [], tw = where ? where.concat() : [];
      for(i = 0; i < len; ++i) { ta[tw[0]] = params[i]; tw.shift(); }
      return len < wlen && len ?
        partialize$.apply(context, [f, ta, tw]) : f.apply(context, ta);
    };
  }
  function clone$(it){
    function fun(){} fun.prototype = it;
    return new fun;
  }
}).call(this);
